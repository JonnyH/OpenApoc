#include <fstream>
#include <iostream>
#include <list>
#include <memory>
#include <string>

#include "serialization_xml.h"

namespace po = boost::program_options;

void writeHeader(std::ofstream &out, const StateDefinition &state)
{
	out << "// GENERATED HEADER - generated by LuaGamestateSupportGen - do not modify directly\n\n"
	    << "#pragma once\n\n"
	    << "#include \"game/state/gamestate.h\"\n\n"
	    << "#include \"game/state/luagamestate_support.h\"\n\n"
	    << "extern \"C\"\n{\n"
	    << "#include <lua.h>\n"
	    << "}\n\n"
	    << "namespace OpenApoc {\n\n"
	    << "static constexpr const char* const LUAGAMESTATE_SUPPORT_VERSION = \""
	    << state.hashString << "\";\n"
	    << "} // namespace OpenApoc\n";
}

void writeSource(std::ofstream &out, const StateDefinition &state,
                 const std::string &outputHeaderFile)
{
	out << "// GENERATED SOURCE - generated by LuaGamestateSupportGen - do not modify directly\n\n";
	out << "#include \"framework/luaframework.h\"\n";
	out << "#include \"game/state/luagamestate_support.h\"\n";
	out << "#include \"" << outputHeaderFile << "\"\n\n";
}

int main(int argc, char **argv)
{

	po::options_description desc("Allowed options");
	// These operator() really screw up clang-format
	// clang-format off
	desc.add_options()
		("help", "Show help message")
		("xml,x", po::value<std::string>(),"Input XML file")
		("output-header,h", po::value<std::string>(), "Path to output generated header file")
		("output-source,o", po::value<std::string>(), "Path to output generated source file")
	;
	// clang-format on

	po::variables_map vm;
	po::store(po::parse_command_line(argc, argv, desc), vm);
	po::notify(vm);

	std::string inputXmlPath;
	std::string outputHeaderPath;
	std::string outputSourcePath;

	if (vm.count("help"))
	{
		std::cout << desc << "\n";
		return 1;
	}
	if (!vm.count("xml"))
	{
		std::cerr << "Must specify input XML file\n" << desc << "\n";
		return 1;
	}
	if (!vm.count("output-header"))
	{
		std::cerr << "Must specify output header file\n" << desc << "\n";
		return 1;
	}
	if (!vm.count("output-source"))
	{
		std::cerr << "Must specify output source file\n" << desc << "\n";
		return 1;
	}

	inputXmlPath = vm["xml"].as<std::string>();
	outputHeaderPath = vm["output-header"].as<std::string>();
	outputSourcePath = vm["output-source"].as<std::string>();

	std::ifstream inputXmlFile(inputXmlPath);
	if (!inputXmlFile)
	{
		std::cerr << "Failed to open input XML file \"" << inputXmlPath << "\"\n";
		return 1;
	}

	std::ofstream outputSourceFile(outputSourcePath);
	if (!outputSourceFile)
	{
		std::cerr << "Failed to open output source file at \"" << outputSourcePath << "\"\n";
		return 1;
	}

	std::ofstream outputHeaderFile(outputHeaderPath);
	if (!outputHeaderFile)
	{
		std::cerr << "Failed to open output header file at \"" << outputHeaderPath << "\"\n";
		return 1;
	}

	StateDefinition state;
	if (!readXml(inputXmlFile, state))
	{
		std::cerr << "Reading input XML file \"" << inputXmlPath << "\" failed\n";
		return 1;
	}

	// sort the items by name so they are ordered like a DFS iteration in a trie
	std::sort(
	    state.enums.begin(), state.enums.end(),
	    [](const SerializeEnum &lhs, const SerializeEnum &rhs) { return lhs.name < rhs.name; });
	std::sort(
	    state.objects.begin(), state.objects.end(),
	    [](const SerializeObject &lhs, const SerializeObject &rhs) { return lhs.name < rhs.name; });

	writeHeader(outputHeaderFile, state);
	writeSource(outputSourceFile, state, outputHeaderPath);

	return 0;
}
